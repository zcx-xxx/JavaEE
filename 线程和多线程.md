# 1.线程和多线程

## 1.1基本概念

> 在Java中每一个程序都有一个默认的线程，就是当$JVM$发现main方法时启动的线程，我们又把这个线程叫做Java程序的**主线程**，在Java程序中如果想启动更多的线程必须借助main方法，即主线程是产生其他线程的线程。在main方法的执行过程中如果没有启动其他的线程，则当方法执行完最后一条语句，$JVM$机会结束应用程序，我们把这样的程序称为单线程程序；如果在main方法的执行过程中又启动了其他的线程，那么$JVM$就会在主线程和其他线程之间轮流切换，$JVM$要等程序中所有的线程都运行结束之后才结束程序，不是主线程运行完毕就结束，我们把这样的程序称为多线程程序。

1. 程序，进程和线程的区别：

   程序：一段静态的代码

   **进程**：程序的一次执行，一个程序对应一个进程，进程之间的数据状态完全独立，进程是系统进行资源分配的基本单位，一个进程可以产生多个线程。

   **线程**：执行程序的最小单位，是占用CPU的基本单位，同一类线程共享同一块内存资源。

2. 开启一个线程，在$java$中必须使用Thread的对象或其子类的对象调用start（）方法。不可以直接调用run()方法，那样只是简单的方法调用，并未开启一个新的线程。

3. 线程的生命周期：

   1）新建状态：**线程对象已经创建（new 了一个线程类对象）**，还**没有在其上调用start()方法**

   2）可运行状态：当线程**调用start方法**，但**调度程序还没有把它选定**为运行线程时线程所处的状态

   3）运行状态：线程**调度程序从可运行池中选择**一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一方式

   4）等待/阻塞/睡眠状态：其共同点是：线程仍旧**是活的**，但是当前没有条件运行。它是可运行的，当某件事件出现，他可能返回到可运行状态

   5）死亡状态：当线程的run()方法完成时就认为它死去。**线程一旦死亡，就不能复生**。 一个死去的线程上调用start()方法，会抛出$java.lang.IllegalThreadStateException$异常

## 1.2进程的创建

1. 线程的两种创建方式

~~~java
public class Test{
    public static void main(String[] args) {
        Runnable thread1 = new MyThread1();
        MyThread2 thread2 = new MyThread2();

        //使用thread1创建Thread的对象
        Thread thread = new Thread(thread1);

        thread.start();
        thread2.start();
        
    }
}

//实现Runnable接口，MyThread1实例化的对象并不是线程类的对象
class MyThread1 implements Runnable{

    @Override
    public void run(){
        for(int i = 0; i < 1000; ++i){
            System.out.println("MyThread1-------------------");
        }
    }
}

//继承自Thread类，重写run（）方法，MyThread2实例化的对象是线程类对象
class MyThread2 extends Thread{

    @Override
    public void run(){
        for(int i = 0; i < 1000; i++){
            System.out.println("MyThread2*******************");
        }
    }
}
~~~

> 两种创建方式的对比
>
> * 继承Thread类实现多线程
>
>   优点：编写简单，如果需要访问当前线程直接使用this即可获得当前线程.
>
>   缺点：因为线程类已经继承了Thread类，不能再继承其他的父类
>
> * 实现Runnable接口
>
>   优点：线程类只实现了$Runable$接口，还可以继承其他的类. 这种方式可以多个线程共享同一个目标(target)对象，非常适合多个相同线程来处理同一份资源的情况，从而可以将代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想
>
>   缺点：编程稍微复杂，需要访问当前线程，必须使用$Thread.currentThread()$方法

2. 其他常用的线程类方法

~~~java
public class Test{
    public static void main(String[] args) {
        Runnable r = new MyThread1();
        Thread thread1 = new Thread(r);
        thread1.start();

        MyThread2 thread2 = new MyThread2();
        thread2.start();

        System.out.println(Thread.currentThread().getName());
        /**main */
    }
}

class MyThread2 extends Thread{

    @Override
    public void run(){
        this.setName("zcx one");
        System.out.println(this.getName());
        /**zcx one */
    }
}

class MyThread1 implements Runnable{

    @Override
    public void run(){
        Thread.currentThread().setName("zcx two");
        System.out.println(Thread.currentThread().getName());
        /**zcx two */
    }
}

/*
1. 线程类对象.setName()        设置指定线程类对象的名字
2. 线程类对象.getName()        获得指定线程类对象的名字
3. Thread.currentThread()     获得当前正在执行的线程的引用  
4. 注意：在MyThread2中，this即代表当前的线程类对象，因为他继承自Thread；而MyThread1是实现了Runnable接口，this不代表当前正在执行的线程类对象，需要使用Thread.currentThread()获得当前正在执行的线程类对象
5. 只有调用start()方法才是开启一个线程，直接调用run()方法，只是简单的方法调用
*/
~~~

3. sleep()方法：让指定的线程休眠一段时间，注意，该方法为静态方法，在哪一个线程内部调用，让哪一个线程休眠。

~~~java
public class Test{
    public static void main(String[] args) {
        MyThread2 thread2 = new MyThread2();

        thread2.start();
    }
}

class MyThread2 extends Thread{

    @Override
    public void run(){
        int cnt = 0;
        while(true){
            try{
                sleep(1000);                  //休眠，在哪一个线程调用，哪一个线程休眠
                if(cnt == 10){
                    this.interrupt();         //将线程打断
                }
            } catch(InterruptedException e){
                return;
            }

            System.out.println("haha" + cnt);
            ++cnt;
        }
    }
}
~~~

